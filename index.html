<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ESGeopardy — 2024 ESG Edition (Static)</title>
  <style>
    :root{
      --bg:#ffffff;--text:#111827;--muted:#6b7280;--indigo50:#eef2ff;--indigo100:#e0e7ff;
      --blue700:#1d4ed8;--blue800:#1e40af;--amber200:#fde68a;--amber300:#fcd34d;--emerald100:#d1fae5;--emerald200:#a7f3d0;
      --gray200:#e5e7eb;--gray300:#d1d5db;--fuchsia700:#a21caf;--overlay:rgba(0,0,0,.5);
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans",sans-serif;}
    .container{max-width:72rem;margin:0 auto;padding:1.5rem}
    h1{font-size:1.875rem;line-height:2.25rem;margin:0 0 .25rem;font-weight:700}
    p{margin:.25rem 0}
    .muted{color:var(--muted)}
    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center}
    .btn{appearance:none;border:0;border-radius:12px;padding:.5rem 1rem;cursor:pointer;font-weight:600}
    .btn-primary{background:#111827;color:#fff;box-shadow:0 2px 6px rgba(0,0,0,.15)}
    .btn-primary:hover{box-shadow:0 6px 12px rgba(0,0,0,.18)}
    .btn-alt{background:var(--gray200)}
    .grid{display:grid;grid-template-columns:1fr;gap:.75rem}
    @media (min-width:640px){.grid{grid-template-columns:repeat(4,minmax(0,1fr))}}
    .col{display:flex;flex-direction:column;gap:.75rem}
    .cat{padding:.75rem;text-align:center;border:1px solid var(--indigo100);background:var(--indigo50);border-radius:16px;font-weight:600}
    .tile{position:relative;min-height:110px;padding:.75rem;border-radius:16px;text-align:center;border:1px solid transparent;transition:.15s;cursor:pointer}
    .tile.hidden{background:var(--blue700);color:#fff;border-color:var(--blue800)}
    .tile.hidden:hover{filter:brightness(.95)}
    .tile.clue{background:var(--amber200);color:#111827;border-color:var(--amber300)}
    .tile.clue:hover{filter:brightness(.98)}
    .tile.response{background:var(--emerald100);color:#111827;border-color:var(--emerald200)}
    .tile.response:hover{filter:brightness(.98)}
    .tile.done{background:var(--emerald100);color:#065f46;border-color:var(--emerald200);cursor:not-allowed}
    .tile.done .content{font-weight:600}
    .tile[disabled]{cursor:not-allowed}
    .value-tag{position:absolute;right:.75rem;bottom:.5rem;opacity:.8;font-size:.875rem}
    .flash{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;border-radius:16px;background:rgba(162,28,175,.9);color:#fff;text-align:center;padding:.75rem;animation:pulse 1s infinite}
    @keyframes pulse{0%{opacity:.95}50%{opacity:.65}100%{opacity:.95}}

    .tips summary{cursor:pointer}

    /* Modal */
    .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:var(--overlay);padding:1rem;z-index:50}
    .card{width:100%;max-width:42rem;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);padding:1.25rem}
    .final-toggle{margin-top:1rem;padding:1rem;border-radius:12px;background:var(--indigo50);border:1px solid var(--indigo100);cursor:pointer;user-select:none}

    input[type="url"]{padding:.25rem .5rem;border:1px solid #d1d5db;border-radius:6px;font-size:.9rem;width:280px}
    label{font-size:.85rem}
    .status{margin-top:.5rem;font-size:.8rem;font-style:italic;color:#4b5563}
    .control-panel{display:grid;gap:1rem;margin-top:1.5rem}
    @media (min-width:768px){.control-panel{grid-template-columns:2fr 3fr}}
    .panel{padding:1rem;border-radius:16px;border:1px solid var(--indigo100);background:var(--indigo50)}
    .panel h2{margin:0 0 .5rem;font-size:1.125rem}
    .contestant-list{display:grid;gap:.5rem}
    .contestant{display:flex;justify-content:space-between;align-items:center;padding:.75rem 1rem;border-radius:12px;background:#fff;border:1px solid var(--gray200);box-shadow:0 1px 2px rgba(15,23,42,.08);transition:.15s;position:relative}
    .contestant.active{border-color:var(--amber300);box-shadow:0 4px 10px rgba(252,211,77,.35);background:var(--amber200)}
    .contestant.connected{border-color:var(--emerald200);box-shadow:0 4px 12px rgba(16,185,129,.25)}
    .contestant-name{font-weight:600;display:flex;align-items:center;gap:.5rem}
    .contestant-tag{font-size:.7rem;text-transform:uppercase;letter-spacing:.06em;padding:.15rem .4rem;border-radius:999px;background:var(--gray200);color:var(--muted)}
    .contestant.connected .contestant-tag{background:var(--emerald100);color:#047857}
    .contestant-score{font-variant-numeric:tabular-nums;font-weight:600}
    .buzzer-grid{display:flex;flex-wrap:wrap;gap:.5rem}
    .buzzer-btn{background:#fff;color:var(--text);border:1px solid var(--gray300);box-shadow:0 1px 2px rgba(15,23,42,.08)}
    .buzzer-btn:disabled{opacity:.55;cursor:not-allowed}
    .buzzer-note{margin-top:.25rem;font-size:.8rem;color:var(--muted)}
    .buzzer-status{margin-top:.5rem;font-size:.85rem;font-weight:600}
    .buzzer-indicator{margin-top:.5rem;font-size:1rem;font-weight:600;padding:.5rem .75rem;border-radius:12px;display:none}
    .buzzer-indicator[data-tone="ready"]{display:block;background:var(--emerald100);color:#065f46}
    .buzzer-indicator[data-tone="active"]{display:block;background:var(--amber200);color:#78350f}
    .buzzer-indicator[data-tone="success"]{display:block;background:var(--emerald100);color:#065f46}
    .buzzer-indicator[data-tone="warn"]{display:block;background:#fee2e2;color:#991b1b}
    .buzzer-indicator[data-tone="info"]{display:block;background:#e0e7ff;color:var(--blue800)}
    .host-controls{margin-top:.75rem;padding:.75rem;border-radius:12px;background:#fff;border:1px dashed var(--gray300)}
    .host-controls h3{margin:0 0 .5rem;font-size:1rem}
    .host-controls .btn{min-width:6.5rem}
    .host-controls .btn:disabled{opacity:.5;cursor:not-allowed}
    .host-controls.active{border-style:solid;border-color:var(--amber300);box-shadow:0 0 0 2px rgba(252,211,77,.35)}
    body.role-contestant [data-role="host-only"]{display:none !important}
    .double-panel{margin-top:.75rem;padding:.75rem;border-radius:12px;background:#fff;border:1px solid var(--amber300);display:flex;flex-direction:column;gap:.5rem;box-shadow:0 4px 12px rgba(252,211,77,.25)}
    .double-panel h3{margin:0;font-size:1rem;color:var(--blue800)}
    .double-panel label{font-weight:600}
    .double-panel-controls{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center}
    .network-card{margin-top:.75rem;padding:.75rem;border-radius:12px;background:#fff;border:1px solid var(--gray200);box-shadow:0 1px 3px rgba(15,23,42,.1);display:flex;flex-direction:column;gap:.5rem}
    .network-code{font-size:1.5rem;font-weight:700;letter-spacing:.25em;text-align:center;padding:.5rem;border-radius:10px;background:var(--indigo50);border:1px solid var(--indigo100)}
    .share-link{width:100%;padding:.35rem .5rem;border-radius:8px;border:1px solid var(--gray300);font-size:.85rem}
    .join-requests{margin-top:.75rem;padding:.75rem;border-radius:12px;background:#fff;border:1px solid var(--gray200);box-shadow:0 1px 3px rgba(15,23,42,.1);display:flex;flex-direction:column;gap:.75rem}
    .join-requests[hidden]{display:none}
    .join-requests h3{margin:0;font-size:1rem}
    .join-requests-list{display:flex;flex-direction:column;gap:.5rem}
    .join-request-item{display:flex;align-items:center;justify-content:space-between;gap:.75rem;padding-bottom:.5rem;border-bottom:1px solid var(--gray200)}
    .join-request-item:last-child{padding-bottom:0;border-bottom:none}
    .join-request-info{display:flex;flex-direction:column;gap:.15rem}
    .join-request-name{font-weight:600}
    .join-request-meta{font-size:.8rem;color:var(--muted)}
    .join-request-actions{display:flex;flex-wrap:wrap;gap:.4rem}
    .btn-small{padding:.35rem .75rem;font-size:.85rem}
    .contestant-join{margin-top:.75rem;padding:.75rem;border-radius:12px;background:#fff;border:1px solid var(--gray200);box-shadow:0 1px 3px rgba(15,23,42,.1);display:flex;flex-direction:column;gap:.5rem}
    .contestant-join label{display:flex;flex-direction:column;gap:.25rem;font-weight:600;font-size:.85rem}
    .contestant-join input{padding:.45rem .6rem;border-radius:8px;border:1px solid var(--gray300);font-size:1rem}
    .contestant-client{margin-top:.75rem;padding:.75rem;border-radius:12px;background:#fff;border:1px dashed var(--gray300);display:none;flex-direction:column;gap:.5rem}
    .contestant-client.active{display:flex}
    .contestant-client .contestant-name-label{font-weight:700;font-size:1rem}
    .contestant-client .btn-primary{font-size:1.1rem;padding:.85rem 1.25rem}
    .contestant-client .status{font-size:.85rem}
    .status{font-size:.8rem;color:var(--muted)}
    body.role-contestant #buzzerControls{display:none}
    body.role-host [data-role="contestant-only"]{display:none !important}
    body.role-contestant .container{max-width:420px;padding:1.5rem 1rem}
    body.role-contestant header.row{flex-direction:column;gap:.75rem;justify-content:center !important;align-items:center !important;text-align:center}
    body.role-contestant header.row > div{width:100%}
    body.role-contestant .control-panel{display:flex;flex-direction:column;gap:1rem;grid-template-columns:1fr;max-width:420px;margin:0 auto}
    body.role-contestant .control-panel .panel{display:none}
    body.role-contestant .control-panel .panel[data-role="contestant-only"]{display:flex}
    .contestant-panel{flex-direction:column;gap:1rem;align-items:stretch}
    .contestant-panel h2{margin:0;text-align:center}
    .contestant-panel .muted{text-align:center}
    body.role-contestant .contestant-join{padding:0;border:none;box-shadow:none}
    body.role-contestant .contestant-client{border:none}
  </style>
</head>
<body>
  <div class="container">
    <header class="row" style="justify-content:space-between;align-items:flex-end;margin-bottom:1rem;">
      <div>
        <h1>ESGeopardy — 2024 ESG Edition</h1>
        <p class="muted" data-role="host-only">Click once to reveal the <strong>clue</strong>, click again to reveal the <strong>correct response</strong>. After that, the tile is marked as <strong>Played</strong>.</p>
        <p class="muted" data-role="contestant-only" hidden>Enter the room code from the host and your name to connect your remote buzzer.</p>
      </div>
      <div class="row" data-role="host-only">
        <button id="resetBtn" class="btn btn-primary">Reset Board</button>
        <span id="remainingText" class="muted" style="font-size:.9rem">Remaining tiles: 16</span>
      </div>
    </header>

    <div id="board" class="grid" aria-label="Jeopardy board" data-role="host-only"></div>

    <section class="control-panel" aria-label="Scoreboard and buzzer controls">
      <div class="panel" data-role="host-only">
        <h2>Contestants</h2>
        <div id="scoreboardList" class="contestant-list" aria-live="polite"></div>
        <div id="networkStatus" class="status"></div>
      </div>
      <div class="panel" data-role="host-only">
        <h2>Buzzers</h2>
        <p class="buzzer-note">Use the buttons below or press keys <strong>1</strong>, <strong>2</strong>, and <strong>3</strong> to buzz for Contestants 1–3.</p>
        <div id="buzzerControls" class="buzzer-grid"></div>
        <div id="buzzerStatus" class="buzzer-status" aria-live="polite">Buzzers locked</div>
        <div id="buzzerIndicator" class="buzzer-indicator" aria-live="assertive"></div>
        <div id="hostControls" class="host-controls" data-role="host-only" hidden>
          <h3>Host Controls</h3>
          <div class="row" style="flex-wrap:wrap;gap:.5rem">
            <button id="markCorrect" class="btn btn-primary" disabled>Correct</button>
            <button id="markIncorrect" class="btn btn-alt" disabled>Incorrect</button>
            <button id="clearBuzz" class="btn btn-alt" disabled>Clear Buzz</button>
            <button id="revealTile" class="btn btn-primary" disabled>Reveal to contestants</button>
          </div>
        </div>
        <div id="doublePanel" class="double-panel" data-role="host-only" hidden aria-live="polite" style="display:none">
          <h3>Daily Double!</h3>
          <p class="muted" style="margin:0;font-size:.85rem">Set the wager amount before revealing the clue.</p>
          <div class="double-panel-controls">
            <label for="doubleInput" style="display:flex;flex-direction:column;gap:.25rem">
              <span>Wager amount</span>
              <input id="doubleInput" type="number" min="0" step="50" inputmode="numeric" />
            </label>
            <button id="doubleConfirm" class="btn btn-primary" type="button">Lock wager</button>
            <button id="doubleDefault" class="btn btn-alt" type="button">Use default value</button>
          </div>
        </div>
      </div>
    </section>

    <section class="row" style="justify-content:space-between;margin-top:1.25rem;align-items:flex-start;gap:.75rem" data-role="host-only">
      <div class="tips muted" style="font-size:.9rem" data-role="host-only" hidden>
        <details open>
          <summary>Host tips</summary>
          <ul style="margin:.5rem 0 .25rem 1.25rem">
            <li>Keep pace to ~45s per tile to fit an 8-minute round.</li>
            <li>Read the <strong>clue</strong> aloud; contestants respond in the form of a question.</li>
            <li>Skip around categories to keep energy high.</li>
            <li>Use "Reset Board" to reroll the hidden Double Jeopardy tile.</li>
          </ul>
        </details>
      </div>
      <div class="row" style="gap:.5rem;align-items:center">
        <button id="finalBtn" class="btn" style="background:var(--fuchsia700);color:#fff">Final Jeopardy</button>
        <audio id="final-audio" src="JeopardyMusic.mp3" preload="auto" aria-hidden="true"></audio>
      </div>
    </section>
  </div>

  <!-- Final Jeopardy Modal -->
  <div id="modal" class="modal" style="display:none" data-role="host-only">
    <div class="card" role="dialog" aria-labelledby="finalTitle" aria-modal="true">
      <div style="text-align:center">
        <div class="muted" style="letter-spacing:.15em;font-size:.8rem">FINAL JEOPARDY</div>
        <div id="finalTitle" style="margin-top:.25rem;font-weight:600;font-size:1.25rem">ESG Theme</div>
      </div>

      <div id="finalToggle" class="final-toggle" role="button" tabindex="0" aria-pressed="false" title="Click to reveal response">
        <p id="finalContent" style="margin:0;font-size:1.125rem;line-height:1.6"></p>
      </div>

      <div class="row" style="justify-content:flex-end;margin-top:.75rem;gap:.5rem;flex-wrap:wrap">
        <button id="revealBtn" class="btn btn-primary">Reveal Response</button>
        <button id="closeBtn" class="btn btn-alt">Close</button>
      </div>

      <p class="muted" style="margin-top:.5rem;font-size:.8rem">Starting Final Jeopardy ends the game and disables the board. Use <strong>Reset Board</strong> to start a new round.</p>
    </div>
  </div>

  <script>
  // -----------------------------
  // Board Content (4 x 4)
  // -----------------------------
  const params = new URLSearchParams(window.location.search);
  const roleParam = params.get('role');
  const contestantModeRequested = roleParam && roleParam.toLowerCase()==='contestant';
  const IS_HOST = true;
  window.IS_HOST = IS_HOST;
  document.body.classList.remove('role-host','role-contestant');
  document.body.classList.add('role-host');
  document.querySelectorAll('[data-role="host-only"]').forEach(el=>{
    el.removeAttribute('hidden');
  });
  document.querySelectorAll('[data-role="contestant-only"]').forEach(el=>{
    el.setAttribute('hidden','');
  });
  if(contestantModeRequested){
    const containerEl = document.querySelector('.container');
    if(containerEl){
      const notice = document.createElement('p');
      notice.className = 'status';
      notice.style.fontSize = '0.95rem';
      notice.style.fontStyle = 'normal';
      notice.style.fontWeight = '600';
      notice.style.color = '#b91c1c';
      notice.style.marginBottom = '1rem';
      notice.textContent = 'Mobile contestant mode has been removed. Please connect using the main host board.';
      containerEl.insertBefore(notice, containerEl.firstChild);
    }
  }

  const BOARD = [
    { category: "Planet Positive 🌍", clues: [
      { value:100, clue:"Turner is working toward this long-term environmental goal, common across the construction industry.", response:"What is Net-Zero Emissions?" },
      { value:200, clue:"This type of material, such as low-carbon concrete or mass timber, is key to reducing embodied carbon.", response:"What are sustainable building materials?" },
      { value:300, clue:"Turner’s approach to water, waste, and biodiversity shows our commitment to protecting this.", response:"What is the planet (or environment)?" },
      { value:400, clue:"Electrification of fleets, renewable fuels, and green jobsite innovations are part of this broader strategy.", response:"What is decarbonization?" },
    ]},
    { category: "People Power 👥", clues: [
      { value:100, clue:"Turner’s workplace culture is grounded in this value, which means looking out for one another.", response:"What is Active Caring?" },
      { value:200, clue:"Expanding family leave, wellness programs, and ERGs are all about supporting this.", response:"What is employee well-being?" },
      { value:300, clue:"Mentorship, career pathways, and leadership programs help develop this.", response:"What is the next generation of leaders?" },
      { value:400, clue:"The focus of Construction Inclusion Week, and a key Turner priority, is building a culture of this.", response:"What is inclusion (or belonging)?" },
    ]},
    { category: "Community Impact 🤝", clues: [
      { value:100, clue:"Turner partners with local schools, nonprofits, and trade groups to invest in this.", response:"What is the community (or future workforce)?" },
      { value:200, clue:"Food drives, volunteer days, and building gardens are examples of this type of impact.", response:"What is community service (or engagement)?" },
      { value:300, clue:"Programs like ACE Extern and YouthConstruct help young people explore careers in this industry.", response:"What is construction?" },
      { value:400, clue:"Turner’s partnerships with small and diverse businesses strengthen this aspect of local economies.", response:"What is economic development?" },
    ]},
    { category: "Transforming Industry 🏗️", clues: [
      { value:100, clue:"Turner has a long history of ‘firsts’ — like being a founding member of this green building council.", response:"What is the U.S. Green Building Council?" },
      { value:200, clue:"Innovation summits, AI pilots, and Turner Ventures all help Turner drive this.", response:"What is industry transformation (or innovation)?" },
      { value:300, clue:"Transparency, ethics, and ISO certifications demonstrate Turner’s commitment to this.", response:"What is good governance?" },
      { value:400, clue:"Collaborating with clients, partners, and global affiliates helps Turner do this across the construction industry.", response:"What is lead change (or set industry standards)?" },
    ]}
  ];

  BOARD.forEach(col=>{
    col.clues.forEach(clue=>{
      if(typeof clue.baseValue !== 'number') clue.baseValue = clue.value;
      clue.wager = undefined;
    });
  });

  const FINAL = {
    clue: "This is Turner’s guiding vision that connects caring for people, communities, and the planet with building a better future.",
    response: "What is Building Today to Transform Tomorrow™?",
  };

  const getClueValue = (clue)=>{
    if(!clue) return 0;
    const wager = typeof clue.wager === 'number' && !Number.isNaN(clue.wager) ? clue.wager : null;
    return wager!==null ? wager : clue.value;
  };

  const ALLOWED_STATES = new Set(["hidden","clue","response","done"]);
  const nextState = (s)=> s==="hidden"?"clue":(s==="clue"?"response":(s==="response"?"done":"done"));
  const pickRandomTile = ()=>({ col: Math.floor(Math.random()*BOARD.length), row: Math.floor(Math.random()*BOARD[0].clues.length) });

  const CONTESTANTS = [
    { id: 'contestant-1', name: 'Contestant 1', defaultName: 'Contestant 1', key: '1', score: 0, remoteId: null, connected: false },
    { id: 'contestant-2', name: 'Contestant 2', defaultName: 'Contestant 2', key: '2', score: 0, remoteId: null, connected: false },
    { id: 'contestant-3', name: 'Contestant 3', defaultName: 'Contestant 3', key: '3', score: 0, remoteId: null, connected: false },
  ];

  const ROOM_CODE_LENGTH = 4;

  const sanitizeRoomCode = (code)=>{
    if(!code) return '';
    const digits = String(code).replace(/[^0-9]/g,'');
    if(digits.length < ROOM_CODE_LENGTH) return '';
    return digits.slice(0,ROOM_CODE_LENGTH);
  };

  const sanitizeName = (name)=>{
    if(!name) return '';
    return String(name).replace(/[\n\r]+/g,' ').trim().slice(0,40);
  };

  const generateRoomCode = ()=>{
    const min = Math.pow(10, ROOM_CODE_LENGTH-1);
    const max = Math.pow(10, ROOM_CODE_LENGTH) - 1;
    return String(Math.floor(min + Math.random()*(max-min+1)));
  };

  let ROOM_CODE = sanitizeRoomCode(params.get('room'));
  if(IS_HOST && !ROOM_CODE){
    ROOM_CODE = generateRoomCode();
  }

  const wsParam = params.get('ws');
  const wsPortParam = params.get('wsport') || '3001';
  const fallbackHost = (location.hostname && location.hostname.length) ? location.hostname : 'localhost';
  const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
  const WS_URL = wsParam ? wsParam : `${wsProtocol}://${fallbackHost}:${wsPortParam}`;

  let realtimeSocket = null;
  let realtimeOpen = false;
  let hostRegistered = false;
  const realtimeQueue = [];
  let contestantClientId = null;
  let contestantSlotId = null;
  let contestantAssignedKey = null;
  let contestantJoined = false;
  let joinPending = false;
  let contestantPendingRequestId = null;
  let connectionStatusMessage = '';
  let connectionSummaryMessage = '';

  // State
  let states = BOARD.map(col=>col.clues.map(()=>"hidden"));
  let doublePos = pickRandomTile();
  let flashingPos = null; // {col,row}
  let gameEnded = false;
  let showFinal = false;
  let finalRevealed = false;
  let activeTile = null; // {col,row}
  let buzzersEnabled = false;
  let currentResponder = null;
  let pendingDouble = null; // {col,row}

  // DOM refs
  const boardEl = document.getElementById('board');
  const remainingText = document.getElementById('remainingText');
  const resetBtn = document.getElementById('resetBtn');
  const finalBtn = document.getElementById('finalBtn');
  const audio = document.getElementById('final-audio');

  const modal = document.getElementById('modal');
  const finalToggle = document.getElementById('finalToggle');
  const finalContent = document.getElementById('finalContent');
  const revealBtn = document.getElementById('revealBtn');
  const closeBtn = document.getElementById('closeBtn');
  const scoreboardList = document.getElementById('scoreboardList');
  const joinRequestsPanel = document.getElementById('joinRequestsPanel');
  const joinRequestsList = document.getElementById('joinRequestsList');
  const networkStatusEl = document.getElementById('networkStatus');
  const buzzerControls = document.getElementById('buzzerControls');
  const buzzerStatus = document.getElementById('buzzerStatus');
  const buzzerIndicator = document.getElementById('buzzerIndicator');
  const hostControls = document.getElementById('hostControls');
  const markCorrectBtn = document.getElementById('markCorrect');
  const markIncorrectBtn = document.getElementById('markIncorrect');
  const clearBuzzBtn = document.getElementById('clearBuzz');
  const revealTileBtn = document.getElementById('revealTile');
  const doublePanel = document.getElementById('doublePanel');
  const doubleInput = document.getElementById('doubleInput');
  const doubleConfirmBtn = document.getElementById('doubleConfirm');
  const doubleDefaultBtn = document.getElementById('doubleDefault');
  const hostRoomInfo = document.getElementById('hostRoomInfo');
  const roomCodeDisplay = document.getElementById('roomCodeDisplay');
  const shareLinkInput = document.getElementById('shareLink');
  const hostRealtimeStatus = document.getElementById('hostRealtimeStatus');
  const contestantJoin = document.getElementById('contestantJoin');
  const joinCodeInput = document.getElementById('joinCodeInput');
  const contestantNameInput = document.getElementById('contestantNameInput');
  const joinGameBtn = document.getElementById('joinGameBtn');
  const joinStatus = document.getElementById('joinStatus');
  const contestantClient = document.getElementById('contestantClient');
  const activeContestantName = document.getElementById('activeContestantName');
  const contestantBuzzBtn = document.getElementById('contestantBuzzBtn');
  const contestantClientStatus = document.getElementById('contestantClientStatus');

  if(hostRealtimeStatus){
    hostRealtimeStatus.textContent = 'Contestants now play using the shared board only.';
  }
  setNetworkStatus('In-person play only.');
  updateNetworkSummary();

  if(shareLinkInput){
    shareLinkInput.addEventListener('focus', ()=>{ try{ shareLinkInput.select(); }catch(_){ /* ignore */ } });
    shareLinkInput.addEventListener('click', ()=>{ try{ shareLinkInput.select(); }catch(_){ /* ignore */ } });
  }

  if(IS_HOST){
    updateHostShareLink();
  } else if(joinCodeInput && ROOM_CODE){
    joinCodeInput.value = ROOM_CODE;
  }

  const contestantEls = new Map();
  const scoreEls = new Map();
  const nameLabelEls = new Map();
  const tagEls = new Map();
  const buzzerBtnEls = new Map();
  const keyToContestant = new Map();
  const pendingJoinRequests = new Map();

  const CLIENT_ID = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  const CHANNEL_NAME = 'esg-jeopardy-sync';
  const STORAGE_KEY = `__${CHANNEL_NAME}`;
  const broadcastChannel = typeof BroadcastChannel === 'function' ? new BroadcastChannel(CHANNEL_NAME) : null;

  if(broadcastChannel){
    broadcastChannel.onmessage = (event)=>{
      const data = event && event.data;
      if(!data || data.senderId === CLIENT_ID) return;
      handleSyncMessage(data);
    };
  } else {
    window.addEventListener('storage', (event)=>{
      if(event.key !== STORAGE_KEY || !event.newValue) return;
      try{
        const data = JSON.parse(event.newValue);
        if(!data || data.senderId === CLIENT_ID) return;
        handleSyncMessage(data);
      }catch(e){
        console.warn('Failed to parse sync message', e);
      }
    });
  }

  function broadcast(type,payload,options={}){
    if(!IS_HOST) return;
    const message = { senderId: CLIENT_ID, type, payload, ts: Date.now() };
    if(options.local !== false){
      if(broadcastChannel){
        try{ broadcastChannel.postMessage(message); }catch(e){ console.warn('Broadcast channel failed', e); }
      } else {
        try{
          localStorage.setItem(STORAGE_KEY, JSON.stringify(message));
          localStorage.removeItem(STORAGE_KEY);
        }catch(e){
          console.warn('LocalStorage broadcast failed', e);
        }
      }
    }
    if(options.remote !== false){
      sendRealtime({ action: 'broadcast', payload: message });
    }
  }

  function flushRealtimeQueue(){
    if(!realtimeSocket || realtimeSocket.readyState !== WebSocket.OPEN) return;
    let i = 0;
    while(i < realtimeQueue.length){
      const item = realtimeQueue[i];
      const requireHostReady = !(item.options && item.options.requireHostReady === false);
      if(IS_HOST && requireHostReady && !hostRegistered){
        i += 1;
        continue;
      }
      const payload = Object.assign({}, item.message);
      if(!payload.roomCode && ROOM_CODE){
        payload.roomCode = ROOM_CODE;
      }
      try{
        realtimeSocket.send(JSON.stringify(payload));
      }catch(err){
        console.warn('Failed to send realtime message', err);
        break;
      }
      realtimeQueue.splice(i,1);
    }
  }

  function sendRealtime(message,options={}){
    if(!message || typeof message !== 'object') return;
    const requireHostReady = !(options && options.requireHostReady === false);
    const payload = Object.assign({}, message);
    if(!payload.roomCode && ROOM_CODE){
      payload.roomCode = ROOM_CODE;
    }
    if(!realtimeSocket || realtimeSocket.readyState !== WebSocket.OPEN || (IS_HOST && requireHostReady && !hostRegistered)){
      realtimeQueue.push({ message: payload, options: { requireHostReady } });
      return;
    }
    try{
      realtimeSocket.send(JSON.stringify(payload));
    }catch(err){
      console.warn('Realtime send failed', err);
      realtimeQueue.push({ message: payload, options: { requireHostReady } });
    }
  }

  function renderNetworkStatus(){
    if(!networkStatusEl) return;
    const segments = [];
    if(connectionStatusMessage) segments.push(connectionStatusMessage);
    if(connectionSummaryMessage) segments.push(connectionSummaryMessage);
    networkStatusEl.textContent = segments.join(' — ');
  }

  function setNetworkStatus(text){
    connectionStatusMessage = text || '';
    renderNetworkStatus();
  }

  function setHostStatus(text){
    if(hostRealtimeStatus) hostRealtimeStatus.textContent = text || '';
  }

  function setJoinFeedback(text){
    if(joinStatus) joinStatus.textContent = text || '';
  }

  function setContestantStatus(text){
    if(contestantClientStatus) contestantClientStatus.textContent = text || '';
  }

  function clearJoinRequests(){
    pendingJoinRequests.clear();
    if(joinRequestsPanel) joinRequestsPanel.setAttribute('hidden','');
    if(joinRequestsList) joinRequestsList.innerHTML = '';
  }

  function respondToJoinRequest(requestId, decision){
    if(!IS_HOST || !requestId) return;
    const entry = pendingJoinRequests.get(requestId);
    if(entry){
      entry.working = true;
      pendingJoinRequests.set(requestId, entry);
    }
    renderJoinRequests();
    const action = decision === 'approve' ? 'approve-contestant' : 'deny-contestant';
    sendRealtime({ action, payload: { requestId } }, { requireHostReady: true });
  }

  function renderJoinRequests(){
    if(!IS_HOST || !joinRequestsPanel || !joinRequestsList) return;
    const entries = Array.from(pendingJoinRequests.values()).sort((a,b)=>(a.requestedAt||0)-(b.requestedAt||0));
    joinRequestsList.innerHTML = '';
    if(entries.length === 0){
      joinRequestsPanel.setAttribute('hidden','');
      return;
    }
    joinRequestsPanel.removeAttribute('hidden');
    entries.forEach(entry=>{
      if(!entry || !entry.requestId) return;
      const item = document.createElement('div');
      item.className = 'join-request-item';

      const info = document.createElement('div');
      info.className = 'join-request-info';
      const nameEl = document.createElement('span');
      nameEl.className = 'join-request-name';
      nameEl.textContent = entry.name || 'Contestant';
      info.appendChild(nameEl);
      const meta = document.createElement('span');
      meta.className = 'join-request-meta';
      meta.textContent = 'Waiting for host approval';
      info.appendChild(meta);
      item.appendChild(info);

      const actions = document.createElement('div');
      actions.className = 'join-request-actions';
      const acceptBtn = document.createElement('button');
      acceptBtn.type = 'button';
      acceptBtn.className = 'btn btn-primary btn-small';
      acceptBtn.textContent = 'Accept';
      acceptBtn.disabled = !!entry.working;
      acceptBtn.addEventListener('click', ()=>respondToJoinRequest(entry.requestId, 'approve'));
      actions.appendChild(acceptBtn);

      const denyBtn = document.createElement('button');
      denyBtn.type = 'button';
      denyBtn.className = 'btn btn-alt btn-small';
      denyBtn.textContent = 'Decline';
      denyBtn.disabled = !!entry.working;
      denyBtn.addEventListener('click', ()=>respondToJoinRequest(entry.requestId, 'deny'));
      actions.appendChild(denyBtn);

      item.appendChild(actions);
      joinRequestsList.appendChild(item);
    });
  }

  function handleJoinRequestAdded(data){
    if(!IS_HOST || !data || !data.requestId) return;
    pendingJoinRequests.set(data.requestId, {
      requestId: data.requestId,
      name: data.name || 'Contestant',
      requestedAt: data.requestedAt || Date.now(),
      working: false,
    });
    renderJoinRequests();
    setHostStatus(`${data.name || 'Contestant'} requested to join.`);
  }

  function handleJoinRequestRemoved(data){
    if(!IS_HOST || !data || !data.requestId) return;
    const entry = pendingJoinRequests.get(data.requestId);
    pendingJoinRequests.delete(data.requestId);
    renderJoinRequests();
    if(!entry) return;
    let message = '';
    const name = entry.name || 'Contestant';
    switch(data.reason){
      case 'approved':
        message = `Approved ${name}.`;
        break;
      case 'denied':
        message = `Declined ${name}.`;
        break;
      case 'left':
        message = `${name} left the queue.`;
        break;
      case 'full':
        message = `No slots available for ${name}.`;
        break;
      default:
        message = `${name}'s request cleared.`;
        break;
    }
    if(message) setHostStatus(message);
  }

  function handleJoinRequestError(data){
    if(!IS_HOST || !data || !data.requestId) return;
    const entry = pendingJoinRequests.get(data.requestId);
    if(entry){
      entry.working = false;
      pendingJoinRequests.set(data.requestId, entry);
      renderJoinRequests();
    }
    if(data.message) setHostStatus(data.message);
  }

  function updateHostShareLink(){
    if(!IS_HOST) return;
    if(roomCodeDisplay) roomCodeDisplay.textContent = ROOM_CODE && ROOM_CODE.length ? ROOM_CODE : '----';
    if(shareLinkInput){
      try{
        const baseHref = window.location.href.split('#')[0];
        const shareUrl = new URL(baseHref, window.location.origin || 'http://localhost');
        shareUrl.search = '';
        shareUrl.hash = '';
        shareUrl.searchParams.set('role','contestant');
        if(wsParam) shareUrl.searchParams.set('ws', wsParam);
        const wsPortQuery = params.get('wsport');
        if(wsPortQuery) shareUrl.searchParams.set('wsport', wsPortQuery);
        shareLinkInput.value = shareUrl.toString();
      }catch(e){
        shareLinkInput.value = '';
      }
    }
  }

  function assignContestantSlot(slotId, info){
    const contestant = CONTESTANTS.find(c=>c.id===slotId);
    if(!contestant) return;
    contestant.name = info && info.name ? info.name : contestant.defaultName;
    contestant.remoteId = info && info.clientId ? info.clientId : null;
    contestant.connected = !!contestant.remoteId;
    updateContestantDisplay();
    broadcastContestants();
    broadcastScores();
    if(IS_HOST){
      const slotNumber = slotId.split('-')[1] || '';
      setHostStatus(`${contestant.name} joined slot ${slotNumber}.`);
    }
  }

  function releaseContestantSlot(slotId){
    const contestant = CONTESTANTS.find(c=>c.id===slotId);
    if(!contestant) return;
    contestant.name = contestant.defaultName;
    contestant.remoteId = null;
    contestant.connected = false;
    updateContestantDisplay();
    broadcastContestants();
    broadcastScores();
    if(IS_HOST){
      const slotNumber = slotId.split('-')[1] || '';
      setHostStatus(`Slot ${slotNumber || slotId} is now open.`);
    }
  }

  function handleIncomingBuzz(data){
    if(!IS_HOST || !data) return;
    const contestant = CONTESTANTS.find(c=>c.id===data.slotId && c.remoteId===data.clientId);
    if(!contestant) return;
    handleBuzz(contestant);
  }

  let remoteBuzzersOpen = false;

  function applyRemoteBuzzersState(state){
    if(IS_HOST || !state) return;
    remoteBuzzersOpen = !!state.open;
    if(contestantBuzzBtn){
      contestantBuzzBtn.disabled = !contestantJoined || !remoteBuzzersOpen;
    }
    const message = state.message || (remoteBuzzersOpen ? 'Buzzers open. Tap to buzz in!' : 'Buzzers locked.');
    setContestantStatus(message);
  }

  function handleBuzzResultMessage(data){
    if(IS_HOST || !data) return;
    if(contestantSlotId && data.contestantId === contestantSlotId){
      setContestantStatus('You buzzed in! Waiting for the host.');
      if(contestantBuzzBtn) contestantBuzzBtn.disabled = true;
    } else if(data.name){
      setContestantStatus(`${data.name} buzzed in first.`);
    }
  }

  function handleJoinAccepted(data){
    joinPending = false;
    contestantJoined = true;
    contestantClientId = data && data.clientId ? data.clientId : null;
    contestantSlotId = data && data.slotId ? data.slotId : null;
    contestantAssignedKey = data && data.key ? data.key : null;
    contestantPendingRequestId = null;
    if(activeContestantName){
      activeContestantName.textContent = data && data.name ? data.name : 'Contestant';
    }
    if(contestantClient){
      contestantClient.classList.add('active');
      contestantClient.removeAttribute('hidden');
    }
    if(contestantJoin){
      contestantJoin.setAttribute('hidden','');
    }
    if(contestantBuzzBtn){
      contestantBuzzBtn.disabled = !remoteBuzzersOpen;
    }
    setJoinFeedback('');
    const slotNumber = contestantSlotId ? contestantSlotId.split('-')[1] : '';
    const slotLabel = slotNumber ? `Contestant ${slotNumber}` : 'Contestant';
    setContestantStatus(`Joined as ${slotLabel}. Wait for the host to open buzzers.`);
  }

  function handleJoinDenied(data){
    joinPending = false;
    contestantJoined = false;
    contestantClientId = null;
    contestantSlotId = null;
    contestantPendingRequestId = null;
    const message = data && data.message ? data.message : 'Unable to join. Try again.';
    setJoinFeedback(message);
    setContestantStatus(message);
  }

  function handleJoinPending(data){
    joinPending = true;
    contestantPendingRequestId = data && data.requestId ? data.requestId : null;
    setJoinFeedback('Waiting for the host to approve…');
    setContestantStatus('Waiting for the host to approve your request.');
  }

  function handleRealtimeMessage(message){
    if(!message || typeof message !== 'object') return;
    const type = message.type;
    switch(type){
      case 'host-registered':
        if(IS_HOST){
          if(message.roomCode){
            ROOM_CODE = sanitizeRoomCode(message.roomCode) || ROOM_CODE;
          }
          hostRegistered = true;
          clearJoinRequests();
          updateHostShareLink();
          setHostStatus('Host connected. Remote buzzer connections are disabled.');
          setNetworkStatus('Connected to buzzer server — remote buzzers disabled.');
          flushRealtimeQueue();
          broadcastContestants();
          broadcastScores();
        }
        break;
      case 'contestant-joined':
        if(IS_HOST) assignContestantSlot(message.slotId, message);
        break;
      case 'contestant-requested':
        handleJoinRequestAdded(message);
        break;
      case 'contestant-request-removed':
        handleJoinRequestRemoved(message);
        break;
      case 'contestant-request-error':
        handleJoinRequestError(message);
        break;
      case 'contestant-left':
        if(IS_HOST){
          releaseContestantSlot(message.slotId);
        } else if(contestantSlotId && message.slotId === contestantSlotId){
          contestantJoined = false;
          contestantClientId = null;
          contestantSlotId = null;
          if(contestantClient) contestantClient.classList.remove('active');
          if(contestantBuzzBtn) contestantBuzzBtn.disabled = true;
          if(contestantJoin) contestantJoin.removeAttribute('hidden');
          setContestantStatus('Disconnected from the game. Rejoin with the room code.');
        }
        break;
      case 'contestant-buzz':
        handleIncomingBuzz(message);
        break;
      case 'sync':
        if(!IS_HOST && message.payload) handleSyncMessage(message.payload);
        break;
      case 'buzzers-state':
        applyRemoteBuzzersState(message.payload || message);
        break;
      case 'buzz-result':
        handleBuzzResultMessage(message.payload || message);
        break;
      case 'join-accepted':
        if(joinGameBtn) joinGameBtn.disabled = false;
        handleJoinAccepted(message);
        break;
      case 'join-pending':
        handleJoinPending(message);
        break;
      case 'join-denied':
        if(joinGameBtn) joinGameBtn.disabled = false;
        handleJoinDenied(message);
        break;
      case 'room-closed':
        if(!IS_HOST){
          joinPending = false;
          if(joinGameBtn) joinGameBtn.disabled = false;
          contestantJoined = false;
          contestantClientId = null;
          contestantSlotId = null;
          contestantPendingRequestId = null;
          if(contestantBuzzBtn) contestantBuzzBtn.disabled = true;
          if(contestantClient){
            contestantClient.classList.remove('active');
            contestantClient.setAttribute('hidden','');
          }
          if(contestantJoin) contestantJoin.removeAttribute('hidden');
          setContestantStatus('Host disconnected. Wait for the host to restart the game.');
          setJoinFeedback('Host disconnected. Try joining again soon.');
        }
        break;
      default:
        break;
    }
  }

  function connectRealtime(){
    if(typeof WebSocket === 'undefined'){
      setNetworkStatus('WebSocket not supported in this browser.');
      if(IS_HOST) setHostStatus('WebSocket unavailable.');
      return;
    }
    if(realtimeSocket) return;
    setNetworkStatus('Connecting to buzzer server…');
    if(IS_HOST) setHostStatus('Connecting to buzzer server…');
    try{
      realtimeSocket = new WebSocket(WS_URL);
    }catch(err){
      console.warn('Failed to connect to realtime server', err);
      setNetworkStatus('Unable to connect to buzzer server.');
      if(IS_HOST) setHostStatus('Unable to connect. Check the server.');
      return;
    }

    realtimeSocket.addEventListener('open', ()=>{
      realtimeOpen = true;
      if(IS_HOST){
        hostRegistered = false;
        setHostStatus('Connected. Registering room (remote buzzers disabled)…');
        setNetworkStatus('Connected to buzzer server — remote buzzers disabled.');
        sendRealtime({ action: 'register-host', roomCode: ROOM_CODE }, { requireHostReady: false });
      } else {
        setNetworkStatus('Connected. Enter the room code from the host.');
      }
      flushRealtimeQueue();
    });

    realtimeSocket.addEventListener('message', (event)=>{
      let data = null;
      try{
        data = JSON.parse(event.data);
      }catch(e){
        return;
      }
      handleRealtimeMessage(data);
    });

    realtimeSocket.addEventListener('close', ()=>{
      realtimeOpen = false;
      if(IS_HOST){
        hostRegistered = false;
        clearJoinRequests();
      }
      setNetworkStatus('Disconnected from buzzer server. Retrying…');
      if(IS_HOST) setHostStatus('Disconnected. Attempting to reconnect…');
      if(!IS_HOST){
        joinPending = false;
        if(joinGameBtn) joinGameBtn.disabled = false;
        contestantJoined = false;
        contestantClientId = null;
        contestantSlotId = null;
        contestantPendingRequestId = null;
        if(contestantBuzzBtn) contestantBuzzBtn.disabled = true;
        if(contestantClient){
          contestantClient.classList.remove('active');
          contestantClient.setAttribute('hidden','');
        }
        if(contestantJoin) contestantJoin.removeAttribute('hidden');
        setJoinFeedback('Lost connection to buzzer server. Trying again…');
      }
      realtimeSocket = null;
      setTimeout(()=>{
        if(!realtimeSocket){
          connectRealtime();
        }
      }, 3000);
    });

    realtimeSocket.addEventListener('error', ()=>{
      setNetworkStatus('Buzzer server connection error.');
      if(IS_HOST) setHostStatus('Connection error.');
    });
  }

  function attemptContestantJoin(){
    if(IS_HOST || joinPending) return;
    const code = sanitizeRoomCode(joinCodeInput ? joinCodeInput.value : ROOM_CODE);
    if(!code || code.length !== ROOM_CODE_LENGTH){
      setJoinFeedback(`Enter the ${ROOM_CODE_LENGTH}-digit room code.`);
      return;
    }
    const name = sanitizeName(contestantNameInput ? contestantNameInput.value : '');
    if(!name){
      setJoinFeedback('Enter your name to join.');
      if(contestantNameInput){
        try{ contestantNameInput.focus(); }catch(_){/* ignore */}
      }
      return;
    }
    ROOM_CODE = code;
    if(joinCodeInput) joinCodeInput.value = code;
    joinPending = true;
    if(joinGameBtn) joinGameBtn.disabled = true;
    setJoinFeedback('Requesting to join…');
    sendRealtime({ action: 'join-contestant', roomCode: code, payload: { name } }, { requireHostReady: false });
  }

  function emitContestantBuzz(){
    if(IS_HOST) return;
    if(!contestantJoined || !contestantSlotId || !contestantClientId || !remoteBuzzersOpen) return;
    sendRealtime({
      action: 'contestant-buzz',
      roomCode: ROOM_CODE,
      payload: {
        slotId: contestantSlotId,
        clientId: contestantClientId,
        name: activeContestantName ? activeContestantName.textContent : undefined,
      }
    }, { requireHostReady: false });
    if(contestantBuzzBtn) contestantBuzzBtn.disabled = true;
    setContestantStatus('Buzz sent! Waiting for the host.');
  }

  function broadcastScores(){
    broadcast('scores',{contestants: CONTESTANTS.map(({id,score})=>({id,score}))});
  }

  function formatScore(value){
    try{
      return new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',maximumFractionDigits:0}).format(value);
    }catch(_){
      return `$${value}`;
    }
  }

  function setIndicator(message,tone='info',options={}){
    if(!message){
      buzzerIndicator.textContent = '';
      buzzerIndicator.removeAttribute('data-tone');
      buzzerIndicator.style.display = 'none';
      if(IS_HOST && options.broadcast !== false){
        broadcast('indicator',{message:'',tone});
      }
      return;
    }
    buzzerIndicator.textContent = message;
    buzzerIndicator.dataset.tone = tone;
    buzzerIndicator.style.display = 'block';
    if(IS_HOST && options.broadcast !== false){
      broadcast('indicator',{message,tone});
    }
  }

  function showDoubleWagerPanel(colIdx,rowIdx){
    if(!doublePanel) return;
    doublePanel.style.display = 'flex';
    doublePanel.removeAttribute('aria-hidden');
    const clue = BOARD[colIdx] && BOARD[colIdx].clues[rowIdx];
    const defaultValue = clue ? getClueValue(clue) || clue.baseValue || 0 : 0;
    if(doubleInput){
      doubleInput.value = defaultValue;
      requestAnimationFrame(()=>{
        try{
          doubleInput.focus({ preventScroll: true });
          doubleInput.select();
        }catch(_){/* ignore focus issues */}
      });
    }
  }

  function hideDoublePanel(){
    if(!doublePanel) return;
    doublePanel.style.display = 'none';
    doublePanel.setAttribute('aria-hidden','true');
  }

  function sanitizeWagerInput(raw){
    if(raw===undefined || raw===null) return null;
    const cleaned = String(raw).replace(/[^0-9-]/g,'');
    if(!cleaned) return null;
    const amount = parseInt(cleaned,10);
    if(Number.isNaN(amount)) return null;
    return Math.max(0,amount);
  }

  function beginDoubleWager(colIdx,rowIdx){
    pendingDouble = { col: colIdx, row: rowIdx };
    const btn = tileBtn(colIdx,rowIdx);
    if(btn) btn.disabled = true;
    if(IS_HOST){
      showDoubleWagerPanel(colIdx,rowIdx);
      setIndicator('Daily Double! Set a wager before reading the clue.', 'info');
    } else {
      setIndicator('Daily Double! Waiting for the host to set a wager.', 'info');
    }
  }

  function finalizeDoubleWager(colIdx,rowIdx,options={}){
    const clue = BOARD[colIdx] && BOARD[colIdx].clues[rowIdx];
    if(!clue) return;
    const amount = getClueValue(clue);
    if(IS_HOST && options.broadcast !== false){
      broadcast('doubleWager',{colIdx,rowIdx,value:amount});
      broadcast('setTileState',{colIdx,rowIdx,state:'clue',value:amount});
    }
    setTileState(colIdx,rowIdx,'clue',{...options,broadcast:false});
    updateRemaining();
  }

  function submitDoubleWager({useDefault=false}={}){
    if(!pendingDouble || !IS_HOST) return;
    const { col, row } = pendingDouble;
    const clue = BOARD[col] && BOARD[col].clues[row];
    if(!clue) return;
    let amount = null;
    if(useDefault){
      amount = clue.baseValue ?? clue.value ?? 0;
    } else {
      const parsed = sanitizeWagerInput(doubleInput ? doubleInput.value : null);
      amount = parsed !== null ? parsed : (clue.baseValue ?? clue.value ?? 0);
    }
    clue.wager = amount;
    pendingDouble = null;
    hideDoublePanel();
    finalizeDoubleWager(col,row);
  }

  function updateHostControls(){
    const hasResponder = !!currentResponder;
    [markCorrectBtn,markIncorrectBtn,clearBuzzBtn].forEach(btn=>{ if(btn) btn.disabled = !hasResponder; });
    if(hostControls) hostControls.classList.toggle('active', hasResponder);
    if(revealTileBtn){
      const canReveal = !!activeTile && states[activeTile.col][activeTile.row]==='clue';
      revealTileBtn.disabled = !canReveal;
    }
  }

  function updateContestantDisplay(){
    CONTESTANTS.forEach(contestant=>{
      const row = contestantEls.get(contestant.id);
      const scoreEl = scoreEls.get(contestant.id);
      const nameLabel = nameLabelEls.get(contestant.id);
      const tag = tagEls.get(contestant.id);
      const buzzerBtn = buzzerBtnEls.get(contestant.id);
      if(scoreEl) scoreEl.textContent = formatScore(contestant.score);
      if(nameLabel) nameLabel.textContent = contestant.name;
      if(tag) tag.textContent = contestant.connected ? 'Connected' : 'In-person play';
      if(row){
        row.classList.toggle('active', !!currentResponder && currentResponder.id===contestant.id);
        row.classList.toggle('connected', !!contestant.connected);
      }
      if(buzzerBtn){
        buzzerBtn.textContent = `${contestant.name} (${contestant.key})`;
        buzzerBtn.setAttribute('aria-label', `Buzz for ${contestant.name} (key ${contestant.key})`);
      }
    });
    updateNetworkSummary();
  }

  function updateNetworkSummary(){
    connectionSummaryMessage = 'Contestants should use this board to buzz in.';
    renderNetworkStatus();
  }

  function broadcastContestants(){
    if(!IS_HOST) return;
    broadcast('contestants',{list: CONTESTANTS.map(c=>({ id: c.id, name: c.name, connected: !!c.connected }))});
  }

  function sendBuzzersState(state){
    if(!IS_HOST) return;
    const payload = {
      open: !!(state && state.open),
      message: state && state.message ? state.message : '',
    };
    sendRealtime({ action: 'buzzers-state', payload }, { requireHostReady: true });
  }

  function applyScores(data){
    if(!Array.isArray(data)) return;
    data.forEach(item=>{
      if(!item) return;
      const contestant = CONTESTANTS.find(c=>c.id===item.id);
      if(contestant && typeof item.score === 'number'){
        contestant.score = item.score;
      }
    });
    updateContestantDisplay();
  }

  function applyContestantRoster(list){
    if(!Array.isArray(list)) return;
    list.forEach(item=>{
      if(!item) return;
      const contestant = CONTESTANTS.find(c=>c.id===item.id);
      if(contestant){
        if(item.name) contestant.name = item.name;
        contestant.connected = !!item.connected;
      }
    });
    updateContestantDisplay();
  }

  function disableBuzzers(message='Buzzers locked', options={}){
    buzzersEnabled = false;
    buzzerBtnEls.forEach(btn=>{ btn.disabled = true; });
    buzzerStatus.textContent = message;
    if(IS_HOST && options.broadcast !== false){
      sendBuzzersState({ open: false, message });
    }
  }

  function enableBuzzers(message='Buzzers ready (keys 1-3)', options={}){
    if(gameEnded || !activeTile) return;
    buzzersEnabled = true;
    buzzerBtnEls.forEach(btn=>{ btn.disabled = false; });
    buzzerStatus.textContent = message;
    if(IS_HOST && options.broadcast !== false){
      sendBuzzersState({ open: true, message });
    }
  }

  function resetBuzzerSystem(options={}){
    activeTile = null;
    currentResponder = null;
    disableBuzzers('Buzzers locked', options);
    setIndicator('', 'info', options);
    updateContestantDisplay();
    updateHostControls();
  }

  function prepareBuzzersForClue(options={}){
    if(!activeTile || gameEnded) return;
    currentResponder = null;
    updateContestantDisplay();
    updateHostControls();
    enableBuzzers('Buzzers ready (keys 1-3)', options);
    setIndicator('Buzzers open. Awaiting a contestant.', 'ready', options);
  }

  function handleBuzzerStateForTile(colIdx,rowIdx,state,options={}){
    if(state==='clue'){
      activeTile = {col:colIdx,row:rowIdx};
      prepareBuzzersForClue(options);
      return;
    }

    if(!activeTile || activeTile.col!==colIdx || activeTile.row!==rowIdx) return;

    if(state==='hidden'){
      resetBuzzerSystem(options);
    } else if(state==='response'){
      disableBuzzers('Buzzers locked', options);
      if(!currentResponder) setIndicator('Clue resolved.', 'info', options);
      currentResponder = null;
      updateContestantDisplay();
      updateHostControls();
    } else if(state==='done'){
      activeTile = null;
    }
  }

  function buildContestantUI(){
    contestantEls.clear();
    scoreEls.clear();
    buzzerBtnEls.clear();
    keyToContestant.clear();
    scoreboardList.innerHTML = '';
    buzzerControls.innerHTML = '';

    CONTESTANTS.forEach(contestant=>{
      const row = document.createElement('div');
      row.className = 'contestant';
      row.dataset.contestantId = contestant.id;

      const nameWrap = document.createElement('span');
      nameWrap.className = 'contestant-name';

      const nameLabel = document.createElement('span');
      nameLabel.className = 'contestant-label';
      nameLabel.textContent = contestant.name;
      nameWrap.appendChild(nameLabel);

      const tag = document.createElement('span');
      tag.className = 'contestant-tag';
      tag.textContent = contestant.connected ? 'Connected' : 'Open slot';
      nameWrap.appendChild(tag);

      const scoreEl = document.createElement('span');
      scoreEl.className = 'contestant-score';
      scoreEl.textContent = formatScore(contestant.score);

      row.appendChild(nameWrap);
      row.appendChild(scoreEl);
      scoreboardList.appendChild(row);
      contestantEls.set(contestant.id,row);
      scoreEls.set(contestant.id,scoreEl);
      nameLabelEls.set(contestant.id,nameLabel);
      tagEls.set(contestant.id,tag);

      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'btn buzzer-btn';
      button.textContent = `${contestant.name} (${contestant.key})`;
      button.setAttribute('aria-label', `Buzz for ${contestant.name} (key ${contestant.key})`);
      button.addEventListener('click', ()=>handleBuzz(contestant));
      buzzerControls.appendChild(button);
      buzzerBtnEls.set(contestant.id,button);

      keyToContestant.set(contestant.key,contestant);
      keyToContestant.set(String(contestant.key).toLowerCase(),contestant);
      keyToContestant.set(String(contestant.key).toUpperCase(),contestant);
    });

    disableBuzzers('Buzzers locked');
    setIndicator('');
    updateHostControls();
    updateNetworkSummary();
  }

  function handleBuzz(contestant){
    if(gameEnded || !buzzersEnabled || currentResponder || !activeTile) return;
    currentResponder = contestant;
    disableBuzzers('Buzzers locked');
    updateContestantDisplay();
    updateHostControls();
    setIndicator(`${contestant.name} buzzed in!`, 'active');
    if(IS_HOST){
      sendRealtime({ action: 'buzz-result', payload: { contestantId: contestant.id, name: contestant.name } }, { requireHostReady: true });
    }
  }

  function handleCorrect(){
    if(!currentResponder || !activeTile) return;
    const contestant = currentResponder;
    const value = getClueValue(BOARD[activeTile.col].clues[activeTile.row]) || 0;
    contestant.score += value;
    currentResponder = null;
    updateContestantDisplay();
    updateHostControls();
    disableBuzzers('Buzzers locked');
    setIndicator(`${contestant.name} is correct! Reveal when ready.`, 'success');
    broadcastScores();
  }

  function handleIncorrect(){
    if(!currentResponder || !activeTile) return;
    const contestant = currentResponder;
    const value = getClueValue(BOARD[activeTile.col].clues[activeTile.row]) || 0;
    contestant.score -= value;
    currentResponder = null;
    updateContestantDisplay();
    updateHostControls();
    enableBuzzers('Buzzers reopened');
    setIndicator(`${contestant.name} is incorrect. Buzzers reopened.`, 'warn');
    broadcastScores();
  }

  function handleClear(){
    if(!currentResponder || !activeTile) return;
    const name = currentResponder.name;
    currentResponder = null;
    updateContestantDisplay();
    updateHostControls();
    enableBuzzers('Buzzers reopened');
    setIndicator(`Buzz cleared for ${name}. Awaiting buzz.`, 'info');
  }

  function revealActiveTile(options={}){
    const fromSync = !!options.fromSync;
    const colIdx = options.colIdx ?? (activeTile && activeTile.col);
    const rowIdx = options.rowIdx ?? (activeTile && activeTile.row);
    if(colIdx===undefined || rowIdx===undefined) return;
    if(IS_HOST && !fromSync) broadcast('revealTile',{colIdx,rowIdx});
    setTileState(colIdx,rowIdx,'response',options);
    setTileState(colIdx,rowIdx,'done',options);
    updateRemaining();
  }

  function handleSyncMessage(message){
    if(!message || typeof message !== 'object') return;
    const { type, payload } = message;
    switch(type){
      case 'advanceTile':
        if(payload) advanceTile(payload.colIdx,payload.rowIdx,{fromSync:true});
        break;
      case 'setTileState':
        if(payload){
          if(Object.prototype.hasOwnProperty.call(payload,'value')){
            const clue = BOARD[payload.colIdx] && BOARD[payload.colIdx].clues[payload.rowIdx];
            if(clue){
              clue.wager = typeof payload.value === 'number' ? payload.value : clue.baseValue;
              if(!IS_HOST) pendingDouble = null;
            }
          }
          setTileState(payload.colIdx,payload.rowIdx,payload.state,{fromSync:true,broadcast:false});
        }
        updateRemaining();
        break;
      case 'doubleWager':
        if(payload){
          const clue = BOARD[payload.colIdx] && BOARD[payload.colIdx].clues[payload.rowIdx];
          if(clue){
            clue.wager = typeof payload.value === 'number' ? payload.value : clue.baseValue;
            if(!IS_HOST) pendingDouble = null;
          }
        }
        break;
      case 'scores':
        if(payload) applyScores(payload.contestants);
        break;
      case 'contestants':
        if(payload) applyContestantRoster(payload.list);
        break;
      case 'indicator':
        if(payload) setIndicator(payload.message || '', payload.tone || 'info', {broadcast:false});
        break;
      case 'resetBoard':
        resetBoard({fromSync:true});
        break;
      case 'openFinal':
        openFinal({fromSync:true});
        break;
      case 'closeFinal':
        closeFinal({fromSync:true});
        break;
      case 'toggleFinal':
        if(payload && Object.prototype.hasOwnProperty.call(payload,'force')){
          toggleFinal({fromSync:true, force: payload.force});
        } else {
          toggleFinal({fromSync:true});
        }
        break;
      case 'revealTile':
        if(payload) revealActiveTile({fromSync:true,colIdx:payload.colIdx,rowIdx:payload.rowIdx});
        break;
      default:
        break;
    }
  }

  // Build Board DOM once
  const colEls = [];
  const tileBtn = (colIdx,rowIdx)=>document.getElementById(`tile-${colIdx}-${rowIdx}`);

  function buildBoard(){
    boardEl.innerHTML = '';
    BOARD.forEach((column, colIdx)=>{
      const col = document.createElement('div');
      col.className = 'col';
      const cat = document.createElement('div');
      cat.className = 'cat';
      cat.textContent = column.category;
      col.appendChild(cat);

      column.clues.forEach((item,rowIdx)=>{
        const btn = document.createElement('button');
        btn.id = `tile-${colIdx}-${rowIdx}`;
        btn.className = 'tile hidden';
        btn.setAttribute('aria-label', `Reveal ${item.value} clue`);
        btn.addEventListener('click', ()=>advanceTile(colIdx,rowIdx));
        const content = document.createElement('span');
        content.className = 'content';
        content.style.display = 'block';
        content.style.fontWeight = '600';
        content.style.fontSize = '1.125rem';
        content.style.lineHeight = '1.25';
        content.textContent = item.value;
        btn.appendChild(content);
        const tag = document.createElement('span');
        tag.className = 'value-tag';
        tag.textContent = item.value;
        btn.appendChild(tag);
        col.appendChild(btn);
      });

      colEls.push(col);
      boardEl.appendChild(col);
    });
    updateRemaining();
  }

  function updateRemaining(){
    const remaining = states.flat().filter(s=>s!=="done").length;
    remainingText.textContent = `Remaining tiles: ${remaining}`;
  }

  function setTileState(colIdx,rowIdx,state,options){
    options = options || {};
    states[colIdx][rowIdx] = state;
    const btn = tileBtn(colIdx,rowIdx);
    const item = BOARD[colIdx].clues[rowIdx];
    const content = btn.querySelector('.content');
    btn.classList.remove('hidden','clue','response','done');
    btn.classList.add(state);

    if(state==='hidden'){
      content.textContent = item.value;
      btn.querySelector('.value-tag').style.display = '';
      btn.disabled = false;
      btn.setAttribute('aria-label',`Reveal ${item.value} clue`);
    } else if(state==='clue'){
      content.textContent = item.clue;
      btn.querySelector('.value-tag').style.display = 'none';
      btn.disabled = false;
      btn.setAttribute('aria-label','Reveal correct response');
    } else if(state==='response'){
      content.textContent = item.response;
      btn.querySelector('.value-tag').style.display = 'none';
      btn.disabled = false;
      btn.setAttribute('aria-label','Played');
    } else { // done
      content.textContent = item.response;
      btn.querySelector('.value-tag').style.display = 'none';
      btn.disabled = true;
      btn.setAttribute('aria-label','Correct response revealed');
    }

    handleBuzzerStateForTile(colIdx,rowIdx,state,options);
    if(IS_HOST) updateHostControls();
    if(IS_HOST && options.broadcast !== false && !options.fromSync){
      broadcast('setTileState',{colIdx,rowIdx,state});
    }
  }

  function isFlashingAt(colIdx,rowIdx){
    return !!flashingPos && flashingPos.col===colIdx && flashingPos.row===rowIdx;
  }

  function setFlashing(colIdx,rowIdx,enable){
    const btn = tileBtn(colIdx,rowIdx);
    if(enable){
      const overlay = document.createElement('div');
      overlay.className = 'flash';
      overlay.innerHTML = '<div><div style="font-size:.75rem;letter-spacing:.25em">DOUBLE</div><div style="font-weight:800;font-size:1.5rem;line-height:1">JEOPARDY!</div></div>';
      overlay.dataset.flash = '1';
      btn.appendChild(overlay);
      btn.disabled = true;
    } else {
      const overlay = btn.querySelector('.flash');
      if(overlay) overlay.remove();
      btn.disabled = false;
    }
  }

  function isDoubleAt(colIdx,rowIdx){
    return doublePos && doublePos.col===colIdx && doublePos.row===rowIdx;
  }

  function advanceTile(colIdx,rowIdx,options={}){
    const fromSync = !!options.fromSync;
    if(!fromSync && !IS_HOST) return;
    if(gameEnded && !fromSync) return;
    if(!fromSync && pendingDouble && (pendingDouble.col!==colIdx || pendingDouble.row!==rowIdx)) return;
    const currentState = states[colIdx][rowIdx];
    if(!fromSync && currentState==='clue') return; // wait for explicit reveal control
    if(IS_HOST && !fromSync) broadcast('advanceTile',{colIdx,rowIdx});

    // Double Jeopardy behaviour
    if(isDoubleAt(colIdx,rowIdx)){
      if(currentState==='hidden'){
        flashingPos = {col:colIdx,row:rowIdx};
        setFlashing(colIdx,rowIdx,true);
        setTimeout(()=>{
          setFlashing(colIdx,rowIdx,false);
          flashingPos = null;
          beginDoubleWager(colIdx,rowIdx);
        },2000);
        return;
      }
    }

    // Regular flow
    const next = nextState(currentState);
    setTileState(colIdx,rowIdx,next,options);
    updateRemaining();
  }

  function resetBoard(options={}){
    const fromSync = !!options.fromSync;
    states = BOARD.map(col=>col.clues.map(()=>"hidden"));
    flashingPos = null;
    doublePos = pickRandomTile();
    gameEnded = false;
    showFinal = false;
    finalRevealed = false;
    CONTESTANTS.forEach(contestant=>{ contestant.score = 0; });
    BOARD.forEach(col=>col.clues.forEach(clue=>{ clue.wager = undefined; }));
    pendingDouble = null;
    hideDoublePanel();
    resetBuzzerSystem(fromSync ? {broadcast:false} : {});
    try{ audio.pause(); audio.currentTime = 0; }catch(e){}
    // Re-render tiles
    BOARD.forEach((col,ci)=>col.clues.forEach((_,ri)=>setTileState(ci,ri,'hidden',{broadcast:false})));
    updateContestantDisplay();
    updateHostControls();
    updateRemaining();
    if(IS_HOST && !fromSync){
      broadcast('resetBoard',{});
      broadcastScores();
      broadcastContestants();
    }
  }

  const DEFAULT_FINAL_SRC = 'JeopardyMusic.mp3';

  async function openFinal(options={}){
    const fromSync = !!options.fromSync;
    gameEnded = true; // disables board via disabled attr set when reaching 'done' only; we prevent clicks by short-circuit
    showFinal = true;
    finalRevealed = false;
    resetBuzzerSystem();
    setIndicator('Final Jeopardy in progress. Buzzers disabled.', 'info');
    finalContent.textContent = FINAL.clue;
    finalToggle.setAttribute('aria-pressed','false');
    revealBtn.style.display = '';
    modal.style.display = 'flex';
    if(IS_HOST && !fromSync){
      broadcast('openFinal',{});
    }
    try{
      audio.src = DEFAULT_FINAL_SRC;
      audio.currentTime = 0;
      audio.loop = true;
      await audio.play();
    }catch(e){
      console.warn('Final Jeopardy audio playback failed:', e);
    }
  }
  function closeFinal(options={}){
    const fromSync = !!options.fromSync;
    modal.style.display = 'none';
    showFinal = false;
    if(IS_HOST && !fromSync){
      broadcast('closeFinal',{});
    }
    try{ audio.pause(); audio.currentTime = 0; }catch(e){}
  }
  function toggleFinal(options={}){
    const fromSync = !!options.fromSync;
    if(Object.prototype.hasOwnProperty.call(options,'force')){
      finalRevealed = !!options.force;
    } else {
      finalRevealed = !finalRevealed;
    }
    finalContent.textContent = finalRevealed ? FINAL.response : FINAL.clue;
    finalToggle.setAttribute('aria-pressed', String(finalRevealed));
    revealBtn.style.display = finalRevealed ? 'none' : '';
    if(IS_HOST && !fromSync){
      broadcast('toggleFinal',{force: finalRevealed});
    }
  }

  // Wire up controls
  resetBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; resetBoard(); });
  finalBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; openFinal(); });
  closeBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; closeFinal(); });
  revealBtn.addEventListener('click', ()=>{ if(!IS_HOST || finalRevealed) return; toggleFinal(); });
  finalToggle.addEventListener('click', ()=>{ if(!IS_HOST) return; toggleFinal(); });
  finalToggle.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); if(!IS_HOST) return; toggleFinal(); }});
  if(revealTileBtn) revealTileBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; revealActiveTile(); });
  markCorrectBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; handleCorrect(); });
  markIncorrectBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; handleIncorrect(); });
  clearBuzzBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; handleClear(); });
  if(doubleConfirmBtn) doubleConfirmBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; submitDoubleWager(); });
  if(doubleDefaultBtn) doubleDefaultBtn.addEventListener('click', ()=>{ if(!IS_HOST) return; submitDoubleWager({useDefault:true}); });
  if(doubleInput) doubleInput.addEventListener('keydown', (event)=>{
    if(event.key === 'Enter' && IS_HOST){
      event.preventDefault();
      submitDoubleWager();
    }
  });

  if(joinGameBtn){
    joinGameBtn.addEventListener('click', attemptContestantJoin);
  }
  if(joinCodeInput){
    joinCodeInput.addEventListener('keydown',(event)=>{
      if(event.key === 'Enter'){ event.preventDefault(); attemptContestantJoin(); }
    });
  }
  if(contestantNameInput){
    contestantNameInput.addEventListener('keydown',(event)=>{
      if(event.key === 'Enter'){ event.preventDefault(); attemptContestantJoin(); }
    });
  }
  if(contestantBuzzBtn){
    contestantBuzzBtn.addEventListener('click', emitContestantBuzz);
  }

  hideDoublePanel();
  if(!contestantModeRequested){
    connectRealtime();
  }

  document.addEventListener('keydown',(event)=>{
    if(event.repeat) return;
    const activeTag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toUpperCase() : '';
    if(activeTag==='INPUT' || activeTag==='TEXTAREA') return;
    const contestant = keyToContestant.get(event.key);
    if(!contestant) return;
    event.preventDefault();
    handleBuzz(contestant);
  });

  // Build once and init states
  buildContestantUI();
  buildBoard();
  // Initialize each tile explicitly so content matches state
  BOARD.forEach((col,ci)=>col.clues.forEach((_,ri)=>setTileState(ci,ri,'hidden',{broadcast:false})));

  // Minimal runtime assertions in console (dev aid)
  try{
    console.assert(Array.isArray(BOARD)&&BOARD.length===4,'[TEST] Expected 4 categories');
    BOARD.forEach((c,i)=>{ console.assert(Array.isArray(c.clues)&&c.clues.length===4,`[TEST] Expected 4 clues in column ${i}`); });
    console.assert(ALLOWED_STATES.has(states[0][0]), '[TEST] Valid state');
  }catch(e){ console.warn('[TEST] Runtime assertions raised:',e); }
  </script>
</body>
</html>
